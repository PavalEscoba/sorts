# Структуры дадзеных #
[Артыкул на хабры з чарапашкамі](https://habr.com/post/263765/)  
## Чарга (queues)##
Той элемент, які трапіў у чаргу першым, першым адтуль і вылятае. Як і ў сапраўднай чарзе.  
Так званае **FIFO** (**F**irst **I**n **F**irst **O**ut - першы зайшоў, першы выйшаў).  
Устаўка адбываецца ў канец чаргі (**`push`**), выдаленне першага элементу чаргі(**`shift`**).

## Стек (stack)##
Чарапашка робіць бліны. Першы зроблены блін будзе апошнім сэрвіраваны. Так званае **LIFO** (**L**ast **I**n **F**irst **O**ut);  
Устаўка элементаў у канец (**`push`**), выдаленне таксама з канца (**`pop`**);

## Куча (heap)##
Вежа плотнасці ў якой кінутыя прадметы займаюць месца адпаведна плотнасці прадуктаў. Што адбудзецца з аб'ектам, які кінуць у тую вежу? Ён зойме месца адпаведна той плотнасці, якую мае.  
Куча - гэта **дваічнае дрэва**. А значыць кожны бацькоўскі элемент мае **2 нашчадкі**. Таксама куча мае **вышыню** *logn*, дзе *n* - колькасьць элементаў. Кучы бываюць max-heap(кожны нашчадак - **меншы** свайго бацкі) і min-heap(кожны нашчадак **большы** свайго бацькі).  

Метады працы з кучай.
```javascript
  global heap
  global currSize

  def parent(i): //Получить индекс родителя для i-того элемента
      return i/2

  def left(i): //Получить левый дочерний элемент от i-того
      return 2*i

  def right(i): //Получить правый дочерний элемент от i-того
      return (2*i + 1)
```
Устаўка элемента ў кучу.
гл. heap.png 
Сэнс у тым, што калі элемент, які мы дадалі ў ніз кучы, большы за апошні, то яны перастаўляюцца з бацькам, пакуль усё не стане ўраўнаважанным. 
```javascript
  def swap(a, b): //меняем элемент с индексом a на элемент с индексом b
    temp = heap[a]
    heap[a] = heap[b]
    heap[b] = temp

  def insert(elem):
      global currSize
      
      index = len(heap)
      heap.append(elem)
      currSize += 1
      par = parent(index)
      flag = 0
      while flag != 1:
          if index == 1: //Дошли до корневого элемента
            flag = 1
          elif heap[par] > elem: //Если индекс корневого элемента больше индекса нашего элемента - наш элемент на своем месте
            flag = 1
          else: //Меняем местами родительский элемент с нашим
            swap(par, index)
            index = par
            par = parent(index)
              
      print heap
```
Існуе апэрацыя вымання **максімальнага элемента кучы**. Ёсць код, але на другой мове й можна паглядзець. Складанасць **O(logn)**.
Алгарытм:  
1. Замяніць карнявы элемент самым ніжнім;
2. Параўнаць новы элемент з нашчадкамі. Калі ў правільным парадку - спыніцца;
3. Калі не - замяніць карнявы элемент на адзін з нашчадкаў (меншы для min-heap, большы для max-heap), і паўтарыць крок 2.
  
Можна зрабіць кучу з любога масіва з дапамогай пад-куч. Складанасць **O(n)**. З поспехам прымяняецца для **сартыроўкі кучай** і мае складанасць **O(nlogn)**.
## Хэш-табліца (hash)##
Прыклад з чарапашкай і рознакаляровымі фігуркамі. Чарапашкі заблыталіся. Тады Чарапашка дастала другую гульню, каб насадзіць аднолькавыя (але рознага колеру) фігуры на стрыжань. Адсартыраваныя па форме.  
Зараз мы можам для кожнай камбінацыі колеру й формы выдзяліць па адным стрыжню. Калі мы ведаем адпаведнасць фігуры і нумару стрыжня, то вылічыць дзе знаходзіцца фігурка можна з адной й той жа складанасцю **O(1)**. Канстанта.  
Функцыя па пошуку адпаведнага слупа называецца **хэш-функцыяй**. Зрабіць добрую хэш-функцыю - адна з асноўных задач.  
Калі на адным слупку аказваецца некалькі розных фігурак, больш за 2, то хэш-функцыя ўжо ня надта добрая.  
